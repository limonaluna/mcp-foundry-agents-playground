"""
Shared configuration utilities for MCP Foundry.

Provides centralized configuration loading with support for:
- Environment variables (highest priority)
- mcp-sql-server-deployment-outputs.json (auto-generated by MCP SQL server deployment)
- foundry-deployment-outputs.json (auto-generated by Foundry deployment)
- config.local.json (user's manual overrides)
- config.json (project configuration)
- config.template.json (defaults)
"""

import json
import os
import re
from pathlib import Path
from typing import Dict, Any, Optional


def _substitute_env_vars(value: Any) -> Any:
    """
    Recursively substitute environment variables in configuration values.
    
    Supports:
    - ${VAR_NAME} - Required variable
    - ${VAR_NAME:-default} - Optional with default
    
    Args:
        value: Configuration value (can be string, dict, list, etc.)
        
    Returns:
        Value with environment variables substituted
    """
    if isinstance(value, str):
        # Pattern: ${VAR_NAME} or ${VAR_NAME:-default}
        def replace_env_var(match):
            var_spec = match.group(1)
            if ':-' in var_spec:
                var_name, default = var_spec.split(':-', 1)
                return os.getenv(var_name.strip(), default.strip())
            else:
                var_name = var_spec.strip()
                env_value = os.getenv(var_name)
                if env_value is None:
                    # Return original placeholder if env var not set
                    return match.group(0)
                return env_value
        
        return re.sub(r'\$\{([^}]+)\}', replace_env_var, value)
    elif isinstance(value, dict):
        return {k: _substitute_env_vars(v) for k, v in value.items()}
    elif isinstance(value, list):
        return [_substitute_env_vars(item) for item in value]
    else:
        return value


def load_config() -> Dict[str, Any]:
    """
    Load centralized configuration with priority chain:
    
    1. Environment variables (highest priority)
    2. config/mcp-sql-server-deployment-outputs.json (auto-generated MCP SQL server)
    3. config/foundry-deployment-outputs.json (auto-generated Foundry)
    4. config/config.local.json (user overrides)
    5. config/config.json (existing config for backward compat)
    6. config/config.template.json (defaults)
    
    Returns:
        Merged configuration dictionary with env vars substituted
        
    Raises:
        FileNotFoundError: If no configuration file exists
    """
    foundry_root = Path(__file__).parent.parent  # test/ -> Foundry/
    config_dir = foundry_root / "config"  # config/ folder
    
    # Try to load configuration files in priority order
    config = None
    config_sources = []
    
    # Start with template (lowest priority)
    template_file = config_dir / "config.template.json"
    if template_file.exists():
        with open(template_file) as f:
            config = json.load(f)
        config_sources.append("config/config.template.json")
    
    # Override with existing config.json (backward compatibility)
    config_file = config_dir / "config.json"
    if config_file.exists():
        with open(config_file) as f:
            existing_config = json.load(f)
        if config is None:
            config = existing_config
        else:
            _deep_merge(config, existing_config)
        config_sources.append("config/config.json")
    
    # Override with config.local.json (user's manual overrides)
    local_config_file = config_dir / "config.local.json"
    if local_config_file.exists():
        with open(local_config_file) as f:
            local_config = json.load(f)
        if config is None:
            config = local_config
        else:
            _deep_merge(config, local_config)
        config_sources.append("config/config.local.json")
    
    # Override with mcp-sql-server-deployment-outputs.json (auto-generated MCP SQL server infrastructure)
    deployment_file = config_dir / "mcp-sql-server-deployment-outputs.json"
    if deployment_file.exists():
        with open(deployment_file) as f:
            deployment_config = json.load(f)
        if config is None:
            config = {"infrastructure": deployment_config}
        else:
            if "infrastructure" not in config:
                config["infrastructure"] = {}
            _deep_merge(config["infrastructure"], deployment_config)
        config_sources.append("config/mcp-sql-server-deployment-outputs.json")
    
    # Override with foundry-deployment-outputs.json (auto-generated Foundry infrastructure)
    foundry_deployment_file = config_dir / "foundry-deployment-outputs.json"
    if foundry_deployment_file.exists():
        with open(foundry_deployment_file) as f:
            foundry_config = json.load(f)
        if config is None:
            config = {"project": {}}
        
        # Map foundry deployment outputs to config structure
        if "project" not in config:
            config["project"] = {}
        
        # Use project endpoint (not foundry endpoint) for Agent Service SDK
        if "project" in foundry_config and "endpoint" in foundry_config["project"]:
            config["project"]["endpoint"] = foundry_config["project"]["endpoint"]
        elif "foundry" in foundry_config and "endpoint" in foundry_config["foundry"]:
            # Fallback to foundry endpoint if project endpoint not available (shouldn't happen)
            config["project"]["endpoint"] = foundry_config["foundry"]["endpoint"]
        
        if "project" in foundry_config and "name" in foundry_config["project"]:
            config["project"]["name"] = foundry_config["project"]["name"]
        
        if "model" in foundry_config:
            config["project"]["modelDeployment"] = foundry_config["model"].get("name", config["project"].get("modelDeployment"))
        
        if "location" in foundry_config:
            config["project"]["location"] = foundry_config.get("location", config["project"].get("location"))
        
        config_sources.append("config/foundry-deployment-outputs.json")
    
    if config is None:
        raise FileNotFoundError(
            f"No configuration file found. Please create one of:\n"
            f"  - {template_file} (from template)\n"
            f"  - {config_file} (existing)\n"
            f"  - {local_config_file} (local overrides)"
        )
    
    # Substitute environment variables (highest priority)
    config = _substitute_env_vars(config)
    
    # Store metadata about loaded sources
    config["_config_sources"] = config_sources
    
    return config


def _deep_merge(base: Dict[str, Any], override: Dict[str, Any]) -> None:
    """
    Deep merge override dict into base dict (modifies base in place).
    
    Args:
        base: Base dictionary to merge into
        override: Override dictionary with new values
    """
    for key, value in override.items():
        if key in base and isinstance(base[key], dict) and isinstance(value, dict):
            _deep_merge(base[key], value)
        else:
            base[key] = value


def get_agent_config(agent_type: str) -> Dict[str, Any]:
    """
    Get configuration for a specific agent type.
    
    Args:
        agent_type: Agent type ('sql' or 'github')
        
    Returns:
        Agent configuration dictionary
        
    Raises:
        KeyError: If agent type doesn't exist in config
    """
    config = load_config()
    
    if agent_type not in config.get("agents", {}):
        raise KeyError(
            f"Agent type '{agent_type}' not found in config.json.\n"
            f"Available types: {list(config.get('agents', {}).keys())}"
        )
    
    return config["agents"][agent_type]


def get_project_config() -> Dict[str, Any]:
    """
    Get project configuration.
    
    Returns:
        Project configuration dictionary
    """
    config = load_config()
    return config.get("project", {})


def get_infrastructure_config() -> Dict[str, Any]:
    """
    Get infrastructure configuration (Key Vault, etc.).
    
    Returns:
        Infrastructure configuration dictionary
    """
    config = load_config()
    return config.get("infrastructure", {})


def find_agent_by_name(agents_client, agent_name: str) -> Optional[str]:
    """
    Find an agent ID by name using Azure AI Foundry API.
    
    Args:
        agents_client: Azure AI agents client
        agent_name: Name of the agent to find
        
    Returns:
        Agent ID if found, None otherwise
    """
    try:
        # List all agents - the method might be list_agents() instead of list()
        try:
            agents = agents_client.list_agents()
        except AttributeError:
            # Try alternative method names
            try:
                agents = list(agents_client.list())
            except:
                # If list methods don't work, we need to know the agent ID
                print(f"⚠ Unable to list agents. Agent lookup by name not supported.")
                print(f"  Please configure the agent first, which will display the agent ID.")
                return None
        
        for agent in agents:
            if agent.name == agent_name:
                return agent.id
        return None
    except Exception as e:
        print(f"⚠ Error searching for agent '{agent_name}': {e}")
        return None


def get_mcp_api_key(api_key_source: str = None) -> str:
    """
    Load MCP API key from Azure Key Vault or fallback to local file.
    
    Priority order:
    1. Azure Key Vault (from config.json infrastructure.keyVault.name)
    2. Local file (if api_key_source path is provided)
    3. Environment variable MCP_API_KEY
    
    Args:
        api_key_source: Path to API key file (relative to project root) - optional
        
    Returns:
        API key string
        
    Raises:
        ValueError: If API key cannot be found from any source
    """
    # Option 1: Try Azure Key Vault first (from config)
    try:
        config = load_config()
        infra_config = config.get("infrastructure", {})
        mcp_config = infra_config.get("mcp", {})
        key_vault_config = mcp_config.get("keyVault", {})
        key_vault_name = key_vault_config.get("name")
        secret_name = key_vault_config.get("apiKeySecretName", "mcp-api-key")
        
        if key_vault_name:
            try:
                from azure.identity import DefaultAzureCredential
                from azure.keyvault.secrets import SecretClient
                
                credential = DefaultAzureCredential()
                key_vault_uri = f"https://{key_vault_name}.vault.azure.net"
                secret_client = SecretClient(vault_url=key_vault_uri, credential=credential)
                
                secret = secret_client.get_secret(secret_name)
                return secret.value
            except ImportError:
                print("⚠ Azure Key Vault libraries not available. Install: pip install azure-keyvault-secrets")
            except Exception as e:
                print(f"⚠ Failed to retrieve API key from Key Vault '{key_vault_name}': {e}")
                print("  Falling back to local file or environment variable...")
    except:
        pass  # Config not available, try other methods
    
    # Option 2: Try local file if path provided
    if api_key_source:
        project_root = Path(__file__).parent.parent
        api_key_file = project_root / api_key_source
        
        if api_key_file.exists():
            return api_key_file.read_text().strip()
        else:
            print(f"⚠ API key file not found: {api_key_file}")
    
    # Option 3: Try environment variable
    env_api_key = os.getenv('MCP_API_KEY')
    if env_api_key:
        return env_api_key
    
    # No API key found
    raise ValueError(
        "MCP API key not found. Please set one of the following:\n"
        "1. Configure infrastructure.keyVault.name in deploy/config.json (recommended)\n"
        "2. Create file: deploy/agent/mcp-api-key.txt\n"
        "3. Set MCP_API_KEY environment variable"
    )
